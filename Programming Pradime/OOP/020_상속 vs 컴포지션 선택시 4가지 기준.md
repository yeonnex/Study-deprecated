## 상속 vs 컴포지션

- 상속과 컴포지션 둘 다 **재사용성이 목적**
- 가능/불가능의 측면에서만 보면 많은 경우에 둘 다 사용가능
- 따라서 둘 중 하나를 고를 어떤 **원칙**이 필요

## 상속이냐 컴포지션이냐 그것이 문제로다...

- 언제 무엇을 사용할지는 다음의 경우로 나눠 생각해보자
  1. 기계상의 차이 때문에 하나를 골라야 할 때
  2. 용도 때문에 상속을 고를 수 밖에 없을 때
  3. 관리의 효율성을 고려할 때
  4. 그 외 일반적인 상황

## 1. 기계상의 차이 때문에 하나를 골라야 할 때 (상속시 메모리 문제)

### 상속과 메모리

내 프로그램을 돌리려면 서버가 3대 필요한데, 다른 사람이 만든 똑같은 기능하는 프로그램인데 서버 한대면 돌릴 수 있다. 이거는 서버 비용이 3배 차이! 이런 결과가 나오는 원인 중 하나는 메모리!

- 상속하여 개체 생성 시, 메모리가 하나의 **덩어리**

![image-20211221094127227](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221094127227.png)

### 컴포지션과 메모리

- 컴포지션으로 개체 생성 시, 메모리가 **여러 덩어리**

![image-20211221095229732](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221095229732.png)

이번에는 Person과 Teacher 의 경우를 봐보자. String 형 멤버 변수가 있어서 조금 더 복잡해보이지만, 개념은 같다.

## 상속 관계인 Person - Teacher

![image-20211221095745844](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221095745844.png)

## 컴포지션 관계인 Person - Teacher

![image-20211221100238403](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221100238403.png)

#### new 할 때마다 메모리 블락이 하나씩 만들어진다.

이러한 메모리 상의 차이는 실행 성능에 영향을 미친다.

**상속 모델**과 **컴포지션 모델** 이러한 메모리상의 차이는 용량의 차이도 있지만 이건 되게 미미하고 이것보다는 실행 성는ㅇ에 영향을 많이 미친다. 성능 빠른 프로그램을 원할 때, 이렇게 개체가 여러개로 이루어져있는게 좋지 못하다.

## 프로그램 실행 중 첫 번째 병목점

- CPU 와 메모리 사이의 데이터 전송

![image-20211221101134812](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221101134812.png)

- CPU에 고속의 캐시 메모리를 탑재해서 해결

### 상속 모델로 개체를 만들 경우에는, 개체가 한번에 캐시 메모리에 들어갈 가능성이 높음!!!

### 컴포지션 모델로 만든 개체의 경우, 개체 내 부품 수만큼 캐시 메모리로 로딩할 가능성이 높음.

![image-20211221101624569](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221101624569.png)

최적화 관련 강의들을 보면, 행렬 곱하는 연산에서 캐시에 맞게 최적화를 어떻게 하느냐에 따라 속도가 만배인가 그 정도 차이가 나는 것을 볼 수 있음. 그만큼 최적화에서 이런 부분이 차지하는 부분이 굉장히 높다! 특히 예전에는 그래픽, 영상처리에서 정말 중요했음. 요즘에는 머신러닝! 머신러닝에서 많은 데이터를 얼마나 빠르게 처리하느냐가 굉장히 중요한데, 거기서도 캐시 최적화는 들어갈 수 밖에 없음!

## 프로그램 실행 중 두 번째 병목점

- 새로운 메모리 할당(new)과 해제(delete, release)
- 프로그래밍 언어에 따라 이 둘 중에 특히 느린 것이 있음
- 상속은 메모리 할당과 해제가 딱 한 번씩(메모리 쌉이득)
- 컴포지션은 한번 + 부품 수 만큼

## 결론

상속과 컴포지션 둘 중 하나를 고를 때, 성능을 중요시 한다면 상속을 선호해보자. 물론 컴포지션이 확장성이 훨씬 좋긴하다. 그러나 성능이 중요한 부분이라면 재사용성(확장성)을 포기해서라도... 이런 **특수한 경우에는 컴포지션보다 상속을 선호해야 할 것!**

 

## 2. 용도 때문에 상속을 고를 수 밖에 없을 때

이때는 컴포지션을 못고름

![image-20211221105559062](https://raw.githubusercontent.com/yeonnex/image-server/main/img/image-20211221105559062.png)

### 다른 형의 개체들을 한꺼번에 처리하고 싶을 때

```java
ArrayList<Pet> pets = new ArrayList<Pet>(); // 다양한 개체를 리스트에 저장

pets.add(new Dog(3, "Poppy"));
pets.add(new Cat(1, "Nabi"));

for (Pet pet : pets){
    pet.attack(); // 같은 함수 호출 (다형적으로)
}
```

attack()시, 고양이는 "punch"하고 강아지는 "bite"

**다형성은 상속없이는 안돈다**

그렇기 때문에 이런 구조는 상속을 사용할 수 밖에 없다. 다형성을 사용하려고 상속사용하는 것!

