## 구조체의 한계

```c
// Data
struct Human
{
    int age;
    float height;
}
struct Dog
{
    int age;
    string name;
}
struct Cat
{
    int age;
    string name;
}
```

```c
// Method
void eat(Cat* cat)
{
    
}
void increaseAge(Dog* dog, int age)
{
    
}
void walk(Human* human)
{
    
}
```

struct 안에서는 함수를 정의할 수 없다. 단지 `데이터`만 정의할 수 있다. 이 struct 안의 데이터들을 조작하기 위해서는 메서드가 필요하니, 구조체 바깥에 함수들을 정의한다. 이로 인해 꽤나 불편한 점이 생기는데, 바로 어떤 구조체가 어떤 함수랑 연관있는지 찾기 복잡하다는 것이다. 즉 **데이터와 동작이 분리되어있어**, 데이터만 봤을 때 이 데이터에는 어떤 메서드를 사용할 수 있는지 한눈에 알기 어렵고, 함수만 봤을 때는 어떤 데이터로 이 함수가 돌아가는지를 한눈에 알기 어렵다는 점이다. 이러한 구조체의 한계를 깨고자 `클래스`가 탄생한 것이다. 즉 `구조체` + `동작` = `클래스`

## 개체 모델링

이미 사회에 존재하는 개념 또는 비즈니스 로직을 데이터와 동작으로 이루어진 클래스로 표현해보고, 이 클래스를 토대로 개체를 생성하여 서로 함수도 호출하고 데이터도 전달하는 설계를 하는 것이 개체 모델링이다.

실존하는 물체의 `상태`와 `동작`, 그리고 `물체간의 상호작용`을 만드는 것! 바로 클래스를 사용해서! 클래스는 어떤 물체의 명세이니까!

노트북을 만든다고 생각해보자.

어떻게 만들까?

클래스로 표현할 것이다.

```java
public class Laptop{
    
}
```

> 멤버변수로는 뭐가 필요할까? 노트북 모델명, 제조사, 제작 연도, CPU, RAM, 운영체제, 음 또,,, 스크린... 메서드로는 click(), on/off() 필요할거고... 아냐 생각의 전환을 해보자. 노트북도 조립을 한다고 생각하면 분명 각 부품마다 어떤 회사의 것을 샀는지 적어야 할 수도 있어 그렇다면 단순히 퉁쳐서 한번에 제조사를 적으면 안되고 해당 부품마다를 생각해줘야할듯...

위처럼 온갖 잡다한 생각이 든다. 멤버변수로 뭘 넣고 뭘 넣고... 그런데 개체지향 설계에 과연 정답이 있을까?

## 객체지향 설계에서 처음 맞닥트리는 난관

- **이렇다 할 정답이 없음**
- 사람처럼 생각하자는 것이 OOP
- 다시 말하는데 '사람다움'은 **주관적**
- 한 방에 제대로 설계하기가 어려움

철수 曰 '노트북은 그 자체가 하나의 개체지'
영희 曰 '노트북은 세 개체의 집합이지. 스크린, 키보드, 본체 이렇게 말이야'

#### 같은 노트북이라는 개체를 보더라도 사람마다 관점이 다르다.

따라서 지금부터 개체를 설계하는 다양한 방법을 봐보자. 이때 일일이 코드로 보는 것보다, `클래스 다이어그램`을 이용해 개체를 표현하면 훨씬 더 직관적으로 설계를 구조화하기 편하다.

## 클래스 다이어그램

- 어떤 시스템 안에 들어있는 **클래스들**을 보여줌
  - 클래스 안에는 상태, 동작, 접근 제어자가 있음
  - 클래스간의 관계(상속, 컴포지션 등)
- 시스템의 구조를 보여주기에 적합

### Dog 과 Human 클래스

```java
public class Dog{
    float happiness;
}

public class Human{
    private String name;
    private int age;
    
    public Human(String name, int age) {}
    public String getName() {}
    public void setName(String name) {}
    public void punch(Human enemy) {}
    public void pat(Dog dog) {}
}
```

![](2021-12-01-14-51-05.png)


